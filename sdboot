#!/bin/bash
# SPDX-License-Identifier: MIT
# SPDX-FileCopyrightText: Copyright 2023 SUSE LLC
set -e

# set to --keep-title to use altenate screen. Better for debugging but causes flicker
dialog_altenate_screen=

entryfile=$(mktemp sdboot.XXXXXX)
snapperfile=$(mktemp sdboot.XXXXXX)
tmpfile=$(mktemp sdboot.XXXXXX)
cleanup()
{
	rm -f "$snapperfile" "$entryfile" "$tmpfile"
}
trap cleanup EXIT

helpandquit()
{
	cat <<-EOF
		Usage: $0 [OPTIONS]
		OPTIONS:
		  --verbose  verbose
		  -h         help screen
	EOF
	exit 0
}

log_info()
{
	[ "$verbose" -gt 0 ] || return 0
	echo "$@"
}

d(){
	local retval=0
	# Bash makes it a bit annoying to read the output of a different FD into a variable, it
	# only supports reading stdout by itself. So redirect 3 to stdout and 1 to the real stdout.
	exec {stdoutfd}>&1
	result="$(dialog $dialog_altenate_screen --backtitle "Systemd-boot" --output-fd 3 "$@" 3>&1 1>&${stdoutfd})" || retval=$?
	# Word splitting makes it necessary to use eval here.
	eval "exec ${stdoutfd}>&-"
	return "$retval"
}

# Given the number of total item pairs, outputs the number of items to display at once
menuheight() {
	local height=$(($1 / 2))
	[ "$height" -le "$dh_menu" ] || height="$dh_menu"
	echo "$height"
}

stty_size() {
	set -- $(stty size)
	LINES="$1"
	COLUMNS="$2"
	# stty size can return zero when not ready or
	# its a serial console
	if [ "$COLUMNS" = "0" ] || [ "$LINES" = "0" ]; then
		LINES=24
		COLUMNS=80
	fi

	dh_menu=$((LINES-15))
	dh_text=$((LINES-5))
}

entry_filter=("cat")
update_entries()
{
	[ -z "$1" ] || entry_filter=("$@")
	bootctl list --json=short | "${entry_filter[@]}" > "$entryfile"
}

show_entries()
{
	if ! update_entries 2>"$tmpfile"; then
		d --title "Error" --textbox "$tmpfile" 0 0
		exit 1
	fi

	while true; do
		list=()
		n=0
		default=
		while read -r isdefault isreported type title; do
			color=
			if [ "$isdefault" = "true" ]; then
				default="$n"
				color="\\Zb\Zu"
			fi
			if [ "$isreported" = "false" ]; then
				color="$color\\Z2"
			fi
			if [ "$type" = "loader" ]; then
				color="$color\\Z5"
			fi
			list+=("$n" "$color$title\\Zn")
			n=$((++n))
		done < <(jq '.[]|[.isDefault, if has("isReported") then .isReported else 0 end, if has("type") then .type else "unknown" end, .showTitle]|join(" ")' -r < "$entryfile")
		if [ "${#list}" = 0 ]; then
			d --msgbox "No entries" 0 0
			exit 0
		fi
		d --no-hot-list --colors --ok-label "Options" --cancel-label "Back" --menu "Entries" 0 0 "$(menuheight ${#list[@]})" "${list[@]}" || return 0
		n="$result"

		read -r type < <(jq -r ".[$n]|.type//\"unknown\"" < "$entryfile")

		while true; do
			list=(show json)
			if [ "$type" = "type1" ]; then
				list+=(cat Raw edit Edit set-default "set as default" oneshot "set as one-shot")
			fi
			if [ "$n" != "$default" ] && [ "$type" != "loader" ]; then
				list+=(delete delete)
			fi
			d --no-tags --menu "Entry #$n" 0 0 "$(menuheight ${#list[@]})" "${list[@]}" || break
			action="$result"

			case "$action" in
				show)
					jq ".[$n]" < "$entryfile" > "$tmpfile"
					d --textbox "$tmpfile" 0 0
					;;
				cat)
					read -r fn < <(jq -r ".[$n]|.path" < "$entryfile")
					d --textbox "$fn" 0 0
					;;
				edit)
					read -r fn < <(jq -r ".[$n]|.path" < "$entryfile")
					${EDITOR:-vim} "$fn"
					update_entries
					break
					;;
				delete)
					read -r id < <(jq -r ".[$n]|.id" < "$entryfile")
					bootctl unlink "$id" > "$tmpfile" 2>&1
					d --textbox "$tmpfile" 0 0
					update_entries
					break
					;;
				set-default)
					read -r id < <(jq -r ".[$n]|.id" < "$entryfile")
					bootctl set-default "$id" > "$tmpfile" 2>&1
					d --textbox "$tmpfile" 0 0
					update_entries
					break
					;;
				oneshot)
					read -r id < <(jq -r ".[$n]|.id" < "$entryfile")
					bootctl set-oneshot "$id" > "$tmpfile" 2>&1
					d --textbox "$tmpfile" 0 0
					update_entries
					break
					;;
			esac
		done
	done
}

update_snapper()
{
	 snapper --jsonout list > "$snapperfile"
}

show_snapper()
{
	if ! update_snapper 2>"$tmpfile"; then
		d --title "Error" --textbox "$tmpfile" 0 0
		exit 1
	fi

	while true; do
		list=()
		n=0
		default=
		while read -r n isdefault title; do
			[ "$n" != "0" ] || continue
			if [ "$isdefault" = "true" ]; then
				default="$n"
				title="\\Zb\Zu$title\\Zn"
			fi
			list+=("$n" "$title")
		done < <(jq '.root|.[]|[.number, .default, .description]|join(" ")' -r < "$snapperfile")
		if [ "${#list}" = 0 ]; then
			d --msgbox "No snapshots" 0 0
			exit 0
		fi
		d --no-hot-list --colors --ok-label "Options" --cancel-label "Quit" --menu "Snapshots" 0 0 "$(menuheight ${#list[@]})" "${list[@]}" || exit 1
		n="$result"

		while true; do
			list=(show json entries entries)
			if [ "$n" != "$default" ]; then
				list+=(delete delete)
			fi
			d --no-tags --menu "Snapshot #$n" 0 0 "$(menuheight ${#list[@]})" "${list[@]}" || break
			action="$result"

			case "$action" in
				show)
					jq ".root|.[]|select(.number==$n)" < "$snapperfile" > "$tmpfile"
					d --textbox "$tmpfile" 0 0
					;;
				entries)
					#read -r MACHINE_ID < /etc/machine-id
					#update_entries jq "[.[]|select(.machineId==\"$MACHINE_ID\")|select(has(\"options\"))|select(.options|match(\"@/.snapshots/$n/snapshot\"))]"
					update_entries jq "[.[]|select(has(\"options\"))|select(.options|match(\"root=UUID=$root_uuid .*rootflags=subvol=@/.snapshots/$n/snapshot\"))]"
					show_entries
					;;
			esac
		done
	done
}

main_menu()
{
	while true; do
		list=(snapper snapper sd-boot sd-boot)
		d --no-tags --cancel-label "Quit"  --menu "Main Menu" 0 0 "$(menuheight ${#list[@]})" "${list[@]}" || return 0
		action="$result"

		case "$action" in
			snapper) show_snapper ;;
			sd-boot) show_entries ;;
		esac
	done
}

####### main #######

stty_size

getopttmp=$(getopt -o hc:v --long help,flicker,verbose -n "${0##*/}" -- "$@")
eval set -- "$getopttmp"

while true ; do
        case "$1" in
                -h|--help) helpandquit ;;
		--flicker) dialog_altenate_screen=--keep-tite; shift ;;
		-v|--verbose) verbose=$((++verbose)); shift ;;
                --) shift ; break ;;
                *) echo "Internal error!" ; exit 1 ;;
        esac
done

entry_token=$(bootctl|sed -ne 's/ *token: //p')
root_uuid=$(findmnt / -r -n -o UUID)

main_menu
